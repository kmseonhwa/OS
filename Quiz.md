# 9

1. 모니터로 구현된 Reader-writer 문제에서 reader와 writer 프로세스가 다음과 같은 순서로 프로시져를 호출하였다. (뒤에 이어지는 총 3문제가 같은 상황에 대한 질문임)  
   R1(beginReading) - R2(beginReading) - R1(finishReading) - W1(beginWriting) - R3(beginReading) - W2(beginWriting) - R4(beginReading) - R2(finishReading)  
   모든 호출이 끝났을 때 현재 작업 중인 프로세스는? 모두 고르시오.
   ➡️ W1
2. 모니터로 구현된 Reader-writer 문제에서 reader와 writer 프로세스가 다음과 같은 순서로 프로시져를 호출하였다.  
   R1(beginReading) - R2(beginReading) - R1(finishReading) - W1(beginWriting) - R3(beginReading) - W2(beginWriting) - R4(beginReading) - R2(finishReading)  
   모든 호출이 끝났을 때 조건 큐 readingAllowed에 있는 프로세스를 모두 고르시오.  
   ➡️ R4, R3
3. 모니터로 구현된 Reader-writer 문제에서 reader와 writer 프로세스가 다음과 같은 순서로 프로시져를 호출하였다.  
   R1(beginReading) - R2(beginReading) - R1(finishReading) - W1(beginWriting) - R3(beginReading) - W2(beginWriting) - R4(beginReading) - R2(finishReading)  
   모든 호출이 끝났을 때 조건 큐 writingAllowed에 있는 프로세스를 모두 고르시오.  
   ➡️ W2
4. 교착상태의 발생조건이 아닌 것은?
    - 선점
    - 순환대기, 부분할당, 상호배제는 교착상태의 발생조건에 해당함.
5. 교착상태의 해결 기법 중 일반적으로 자원의 낭비가 가장 심한 것으로 알려진 기법은?
    - 교착상태의 예방
6. 은행가 알고리즘에 의해 다음 상태는 안전상태(safe state)다. 안전 순서를 모두 고르시오. 자원의 총 개수는 10개이다.(퀴즈 참고)
7. 다음은 원형다중 버퍼 문제의 생산자-소비자 문제를 모니터로 구현한 코드이다.  
   생산자 코드 P( )중 밑줄친 bufHasData.signal(); 부분이 생략된 오류를 범했을 때를 가정하고 아래 문제에 답하시오.  
   소비자 프로세스의 코드 C( )엔 오류가 없다.(퀴즈 참고)
8. 모니터로 구현된 식사하는 철학자 알고리즘은 2개의 포크가 모두 사용사능할 때  
   한꺼번에 들고 식사하게 함으로써 교착상태를 피하고 있다.  
   그러나 이 알고리즘은 무기한 연기는 발생할 수도 있는데  
   어떤 경우에 무기한 연기가 발생하는 지 설명하시오.  
   ➡️ 포크를 총 두 개 보유해야 하는데 두 개의 포크가 채워지기 전에 양옆에 철학자한테 계속해서 포크가 가는 상황에 무기한 연기가 발생한다.

# 10

1. 그래프에서 unblocked 상태인 프로세스를 모두 고르시오.(퀴즈 참고)
2. 자원의 최대 개수가 각각 4개, 5개, 4개다. 다음 상테에 대해 맞게 설명한 것을 모두 고르시오.(퀴즈 참고)
3. 단일 프로그래밍 시스템에서 사용한 주소 바인딩 시기는?  
   ➡️ 컴파일 타임
4. 고정분할 다중 프로그래밍 시스템에서 하나의 큐를 사용하여 프로그램 보다 용량이 큰,  
   빈 분할 어디에든 로드하고자 할 때 사용한 주소 바인딩 시기는?  
   ➡️ 적재 시간
5. 프로그램의 논리 주소를 물리 주소로 변환하는 작업을 일컫는 용어는?  
   ➡️ 메모리 사상
6. 단일 프로그래밍 환경에서는 한 번에 하나씩 전체 프로그램을 메모리에 로드해 놓고 실행한다  
   이때 프로그램의 크기가 물리 메모리 크기보다 클 때 사용할 수 있는 기법은?  
   ➡️ 오버레이 기법
7. 주기억장치 관리 기법에서 고정분할 방법에 대한 설명으로 알맞은 것은?  
   ➡️ 프로그래밍 정도(degree)의 최대값이 고정된다.

# 11

> 배치기법에 따른 할당 위치, 페이지 번호, 변위, 실주소 찾기

1. **가변분할 다중 프로그래밍**(6)과 관련없는 것은? ➡️ 비연속 할당
    - 메모리 통합정책, 메모리 배치정책, 단편화 현상은 관련 있음
2. 아래와 같은 메모리 구성에서 18M 크기의 블록을 할당하고자 한다.  
   **최초적합 (first fit)**(8)을 사용할 때 어느 부분에 할당되어야 하는가?
3. 위와 같은 메모리 구성에서 18M 크기의 블록을 할당하고자 한다.  
   **최적적합 (best fit)**(8)을 사용할 때 어느 부분에 할당되어야 하는가?
4. 위와 같은 메모리 구성에서 18M 크기의 블록을 할당하고자 한다.  
   **최악적합 (worst fit)**(8)을 사용할 때 어느 부분에 할당되어야 하는가?
5. 위와 같은 메모리 구성에서 18M 크기의 블록을 할당하고자 한다.  
   **순환최초적합 (next fit)**(8)을 사용할 때 어느 부분에 할당되어야 하는가?
6. 현재 running(실행) 상태에 있는 프로세스가 다음과 같은 경우 어떤 상태로 전이하는 지 선택하시오.  
   **메모리가 부족하여 할당된 메모리를 임시 반납하고 디스크로 스왚됨**  
   ➡️ **suspended**(중단)
7. **가상기억장치**(7)에 대해 바르게 기술한 것은? ➡️ **메모리 보다 큰 크기의 프로그램도 실행 가능 하다.**
    - <오답>
        - 각 프로세스 단위로 연속된 장소에 적재한다.
        - 페이지 크기는 각 프로세스 단위로 결정된다.
        - 각 페이지는 최대 번 씩 메모리에 적재 가능하다.
8. 페이지 크기가 256(=2^8)바이트이고, 주기억장치 용량이 32KB(= 2^15바이트)인 시스템을 가정하자.  
   주기억 장치에 존재하는 **페이지 프레임의 개수**는?  
    ➡️ **2^15 / 2^8** = 2^7 = 128

-   [ ] 9. 페이지 크기가 256(=2^8)바이트이고, 주기억장치 용량이 32KB(= 2^15바이트)인 시스템을 가정하자.  
       8개의 페이지로 구성된 프로그램의 가상주소를 나타내기 위해 **최소한 필요한 비트(bit) 수**는?  
        ➡️ 페이지 크기: 변위, 주기억장치 용량: 실주소  
        ➡️ 왜 9지?

10. 페이지 크기가 256(2^8)바이트이고, 주기억장치 용량이 32KB(= 2^15바이트)인 시스템을 가정하자.  
    가상주소가 이진수로 (10101100111100)라면, **페이지 번호**와 **변위**는 각각 얼마인가?  
    ➡️ 뒤에서부터 페이지 크기 8자리는 변위, 나머지 앞의 6자리는 페이지 번호
11. 현재 running(실행) 상태에 있는 프로세스가 다음과 같은 경우 어떤 상태로 전이하는 지 선택하시오.  
    **페이지 폴트**가 발생함
    ➡️ **blocked(대기)**

# 12

1. 페이징/세그먼테이션 혼합기법에서 다음 각 테이블에서 얻어올 수 있는 최종 정보를 기술하시오.
    - 세그먼트 사상 테이블 탐색
        - PMT address
    - 페이지 사상 테이블 탐색
        - page frame number
    - 연관기억장치에서 hit했을 때
        - page frame number
2. 페이지 번호 찾기, 변위 찾기, 실주소 찾기.
3. 다음 설명 중 페이징 시스템에 반해서 세그먼테이션 시스템에 더 가까운 설명을 모두 고르시오.
    - 블록의 크기가 모두 다름
    - 모든 프로그램을 한꺼번에 적재하지 않음
    - 주기억장치를 미리 분할해 둘 수 없음
    - 블록을 논리적 단위로 나눌 수 있음
    - 블록의 크기가 서로 다름
    - 명령어에서 블록 크기보다 큰 변위값을 사용하는 오류가 가능함
4. 대부분의 가상메모리에서는 페이징/세그먼테이션 혼용기법을 많이 사용한다 이 기법을 잘못 설명한 것은?
    - 프로세스마다 하나의 SMT가 존재하고, 세그먼트 개수만큼 PMT가 존재한다.
    - 메모리 접근권한은 세그먼트 단위로 관리한다.
    - 메모리는 페이지 단위로 할당한다.
    - 연관 직접사상을 사용할 수 있다.
5. 너무 잦은 페이지 부재(page fault) 발생으로 인해 시스템의 성능이 급격하게 저하되는 현상은?  
   ➡️ 스레싱
6. 각 페이지 프레임의 내용이 최근 참조되었는지 여부에 대한 정보와 가장 관련이 높은 것은?  
   ➡️ 참조 비트

# 13

> 알고리즘에 따라 교체되는 페이지 찾기

1. 요구 호출 기법에서 페이지를 메모리에 적재하는 시기는?  
   ➡️ 페이지 폴트가 발생했을 때
2. 다음 중 고정할당 교체기법이 아닌 것은?  
   ➡️ working set
3. 가상기억장치에서 교체할 페이지를 찾을 때 사용하는 LRU 기법에 대해 바르게 설명한 것은?  
   ➡️ 페이지 접근 순서를 정확히 알고 있어야 한다.
4. NUR 교체기법에서 가장 먼저 교체대상이 되는 페이지는?  
   ➡️ 참조비트 0, 갱신비트 0인 페이지
5. NUR(Not Used Recently) 페이지 교체기법에서 사용하는 참조비트의 역할은?
   ➡️ 일정기간 동안 참조하지 않은 페이지를 알려준다.
6. 페이지 프레임이 3개 할당된 시스템에서 1 2 3 4 2 3 순서대로 참조한 상황을 가정한다.  
   추가로 5를 참조해서 페이지 부재가 발생했을때, LRU 알고리즘을 사용하면 **\_\_** 페이지가 교체된다.  
   ➡️ 4
7. 페이지 프레임이 3개 할당된 시스템에서 1 2 3 4 2 순서대로 참조한 상황을 가정한다.  
   추가로 5를 참조해서 페이지 부재가 발생했을때, second chance 알고리즘을 사용하면 **\_\_** 페이지가 교체된다.  
   ➡️ 3
8. 윈도우 크기가 5인 working set 이론을 사용한 교체기법에서  
   1 2 2 1 3 3 4 5 6 3 2 4 2 2 4  
   순서대로 참조하면, 최종 메모리 할당량은 **\_\_** 프레임이다.
   ➡️ 3
9. 너무 잦은 페이지 부재(page fault) 발생으로 인해 시스템의 성능이 급격하게 저하되는 현상은?
   ➡️ 스레싱

## 교체기법

> 고정할당기반: 각 프로세스에 정해진 페이지 프레임을 정해놓고, 그 안에서 교체를 반복함

| 고정할당기반 |        알고리즘        |                                                               문제풀이                                                                |                                                                                                                                                                 특징                                                                                                                                                                  |
| ------------ | :--------------------: | :-----------------------------------------------------------------------------------------------------------------------------------: | :-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: |
|              |          MIN           |                                                                                                                                       |                                                                                                                               가장 오래동안 참조되지 않을 페이지를 교체함. 실현 불가능. 성능 평가 도구.                                                                                                                               |
|              |         random         |                                                                                                                                       |                                                                                                                                            페이지를 줄이려는 어떠한 시도도 하지 않는 기법                                                                                                                                             |
|              |          FIFO          |                                                        먼저 로드된 것을 교체함                                                        |                                                                                                          주기억장치의 할당량을 늘려도 사용빈도가 높은 프로그램이 가장 먼저 로드된다면? 오히려 페이지 부재 횟수가 증가하게 됨                                                                                                          |
|              |          LRU           |                                              가장 오랫동안 참조되지 않은 페이지를 교체함                                              | 지역성 기반. 참조시간을 기록하는 오버헤드가 큼. 페이지 프레임 개수가 페이지보다 적을 땐 계속해서 page fault가 발생할 수도 있음. 실제 시간 대신 카운터로 상대적인 순서를 매김. 참조될 때마다 시간을 기록해야 하는 문제도 있음. 스택을 사용하면 페이지 부재가 발생하지 않은 경우에도 참조된 순서를 유지하기 위해 자료구조를 변경해야 함 |
|              |          LFU           |                                                 가장 참조 횟수가 적은 페이지를 교체함                                                 |                                                                                                                               최근에 적재된 페이지가 참조될 가능성이 존재함에도 불구하고 교체될 수 있음                                                                                                                               |
|              | NUR(Not used recently) |                                               (0, 0) -> (0, 1) -> (1, 0) -> (1, 1) 순서                                               |                                                                                                                                                  (참조, 갱신) 비트로 우선순위를 따짐                                                                                                                                                  |
|              |     Second chance      | FIFO + 참조비트. 참조비트 1인 경우 0으로 바꾸고 재삽입. 교체할 때 빠진 자리가 아닌 맨 끝에 삽입함. 참조한 경우 참조비트 1로 변경 주의 |                                                                                                                                                          참조비트 reset 안함                                                                                                                                                          |
|              |         clock          |                          second chance랑 비슷한데 push&pop 대신 포인터를 이동함. **처음 삽입시 참조비트 1**                           |                                                                                                                                               원형 큐, 포인터 사용. 참조비트 reset 안함                                                                                                                                               |
|              |   Second chance 개선   |                                                     원형 큐 + 참조비트 + 갱신비트                                                     |                                                                                                                                                                                                                                                                                                                                       |

.

> 가변할당기반: 각 프로세스에 할당하는 페이지 프레임수가 변함.

-   페이지 부재 발생 횟수 + 평균 메모리 할당량 고려
-   윈도우 크기(t)는 페이지 부재 서비스 비용(반비례)과 페이지 유지 비용(비례)을 고려해서 결정함

| 가변할당기반 |         알고리즘          |                                                        문제풀이                                                         |                                                 특징                                                 |
| ------------ | :-----------------------: | :---------------------------------------------------------------------------------------------------------------------: | :--------------------------------------------------------------------------------------------------: |
|              |        Working set        |                               주어진 시간 t 동안 참조된 페이지를 모두 주기억장치에 적재함                               | page fault가 발생하지 않아도 t안에 포함되지 않으면 빠짐. 매 순간 집합을 조정해야 하는 오버헤드 발생. |
|              | PFF(page Fault Frequency) | fault가 발생했을 때만 집합을 조정함. fault 발생 간격이 임계값보다 크면 이전 fault부터 실제로 참조한 값만 집합에 포함함. |                                                                                                      |
|              |    VMIN(Variable MIN)     |                                 참조 이후 t안에 참조되면 남기고, 참조 안되면 바로 교체                                  |                                     실현 불가능. 성능 판단 기준.                                     |

.

> 기타고려사항

-   페이지 크기: 작게 하면 내부 단편화를 줄일 수 있으나 페이지 프레임 수가 증가함 = PMT가 커짐.
-   프로그램 구조 재구성: 자신이 실행시키고자 하는 프로그램이 보다 실행을 빠르게 마칠 수 있게 할 수 있음.
-   페이지를 적게 할당받은 프로세스의 메모리 사용량이 더 많은 이유: page fault가 발생한 페이지를 메모리에 가지고 있기 때문.

# 14

> 알고리즘에 따라 가장 먼저 처리하는 시스템

1. 페이징 기법에서 페이지 크기가 작아질수록 발생하는 현상은?
    - 페이지 맵 테이블의 크기가 증가한다.
    - 내부 단편화가 감소한다.
    - 기억장소 이용 효율이 증가한다.
    - 입출력 시간이 늘어난다.
2. 디스크에서 블럭을 읽어오는데 걸리는 시간과 관계없는 것은?
    - 디스크 표면 개수
    - 디스크 회전 속도, 탐색 시간, 블럭 크기느 관계 있음.
3. 현재 running(실행) 상태에 있는 프로세스가 다음과 같은 경우 어떤 상태로 전이하는 지 선택하시오.  
   현재 디스크 헤드가 위치한 같은 트랙에 위치하고 있어 탐색 시간이 불필요한 디스크 블록의 내용을 참조함
    - blocked(대기)
4. 번호가 0부터 255인 256개의 트랙을 가진 이동헤드디스크가 있다.  
   방금 전에 실린더 60의 요청을 처리하고, 헤드는 현재 트랙 90을 처리하고 있다.  
   현재 요청 큐가 다음과 같고, **SSTF** 스케줄링 알고리즘을 사용할 때 다음 번에 제일 먼저 서비스 받을 트랙은 \***\*\_\*\***이다.  
   55, 80, 30, 150, 220, 110  
   ➡️ 80
5. 번호가 0부터 255인 256개의 트랙을 가진 이동헤드디스크가 있다.  
   방금 전에 실린더 60의 요청을 처리하고, 헤드는 현재 트랙 90을 처리하고 있다.  
   현재 요청 큐가 다음과 같고, **C-SCAN** 스케줄링 알고리즘을 사용할 때 다음 번에 제일 먼저 서비스 받을 트랙은 \***\*\_\*\***이다.  
   55, 85, 30, 200, 220, 110  
   ➡️ 110
6. 번호가 0부터 255인 256개의 트랙을 가진 이동헤드디스크가 있다.  
   방금 전에 실린더 60의 요청을 처리하고, 헤드는 현재 트랙 90을 처리하고 있다.  
   현재 요청 큐가 다음과 같고, 현재 트랙 90을 처리하고 있는 동안에 트랙 85, 100에 대한 새로운 요구가 순서대로 발생했다.  
   **N-step SCAN** 스케줄링 알고리즘을 사용할 때 다음 번에 제일 먼저 서비스 받을 트랙은 \_\_\_이다.  
   55, 70, 30, 200, 220, 110  
   ➡️ 110
7. RAID에 대한 설명으로 바른 것을 모두 고르시오.
    - 디스크 인터리빙을 이용할 수 있다.
    - 낮은 비용으로 높은 성능을 추구한다.
8. 100GB 용량의 디스크 8개를 사용하여 디스크 미러링 방식을 사용하는 RAID-1을 구현한다면,  
   디스크의 전체 데이터 저장 용량은 \_\_\_\_GB이다.  
   ➡️ 400

> 탐구 시간 최적화: 어느 실린더에 대한 요구부터 서비스할 것인가. 헤드의 이동을 최소화하기 위함.

| 탐구 시간 최적화 |            알고리즘            |                                         문제풀이                                          |                 특징                 |
| ---------------- | :----------------------------: | :---------------------------------------------------------------------------------------: | :----------------------------------: |
|                  |  FCFS(first com fist served)   |                                 도착한 순서대로 서비스함                                  |                                      |
|                  | SSTF(Shortest Seek Time First) |                        현재 헤드에서 가장 가까운 요구부터 서비스함                        |     무기한 연기가 발생할 수 있음     |
|                  |              SCAN              |   현재 헤드의 진행 방향에서 마지막 실린더까지 갔다가 방향을 바꿔서 남은 서비스를 처리함   |           일반적으로 쓰임            |
|                  |       LOOK(<->elevator)        |             SCAN처럼 끝까지 안 가고 현재 방향의 마지막 요구에서 방향을 전환함             |                                      |
|                  |          N-step SCAN           | 방향을 바꾸는 시점에 놓인 요구들만 처리함. 새로 도착한 요구는 가는 길이어도 처리하지 않음 |   무기한 연기의 가능성 완전히 배제   |
|                  |     C-SCAN(Circular SCAN)      |                  특정방향으로만 요구 처리. 다른 방향은 이동할 때만 쓰임.                  | 양 끝의 요구에 대한 응답 시간을 높임 |
|                  |             C-LOOK             |          C-SCAN과 비슷한데 LOOK처럼 끝까지 안가고 마지막 요구에서 방향을 전환함           |                                      |

.

> 전송 시간 최적화: 디스크 스트라이핑(여러개의 디스크를 하나의 디스크처럼 사용해서 디스크의 성능 증대), RAID

.
| RAID구조 | 알고리즘 | 특징 |
| :------------: | :-----------------------: | :------: |
| | RAID Level 0 | 디스크 스트라이밍. 병렬 방식으로 빠른 입출력. 데이터 중복 기록하지 않아서 신뢰성 낮음. |
| | RAID Level 1 | 미러링(똑같은 디스크가 두개!). 신뢰성 향상. 절반 용량만 사용 가능한 셈. |
| | RAID Level 4 | 하나의 디스크에 패리티 정보를 저장함. 특정 디스크에 보관하기 때문에 병목현상이 발생할 수 있음 |
| | RAID Level 5 | 스트라이핑 + 패리티 분산. 패리티 정보를 모든 드라이브에 나누어서 기록함.|
| | RAID Level 0 + 1 | 스트라이핑 + 미러링 |
