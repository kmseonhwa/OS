# 1주차

1. 운영체제의 초기 발달과정에서 일괄처리시스템으로 발전하면서 컴퓨터시스템의 성능 향상에 미친 주된 영향을 20글자 내외로 설명하시오.
    - 준비 시간을 단축한다.
2. 운영체제의 발달과정에서 테이프를 이용하여 이루어지던 입출력이 디스크를 사용한 스풀링으로 발전하면서 컴퓨터시스템의 성능 향상에 미친 주된 영향을 20글자 내외로 설명하시오.
    - 디스크와 버퍼를 이용한 다중 프로그래밍이 가능하게 되었다.
3. 운영체제의 발달과정에서 유니프로그래밍이 멀티프로그래밍으로 발전하면서 컴퓨터시스템의 성능 향상에 미친 주된 영향을 20글자 내외로 설명하시오.
    - 메모리에 여러 작업이 로드되게 하면서 CPU의 유휴 시간을 줄였다.

# 2주차

1. 부팅할 때 적재되어 메모리에 상주하면서 빈번히 사용되는 OS의 부분을 일컫는 용어는?
    - 커널
2. 프로세서, 프로세스, 프로그램의 차이를 간단하게 설명하시오.
    - 프로세서는 CPU를 의미하고, 프로세스는 실행중인 프로그램을 의미한다. 따라서 프로그램에 따른 프로세스가 2개 이상 존재할 수 있다.
3. PCB에 기본적으로 포함되는 항목을 6가지 이상 적으시오.
    - 프로세스 고유 번호, 프로세스 우선순위, 프로세스 현재 상태, 메모리 관리 정보, I/O 상태정보, 문맥 저장 영역 등이 있다.

# 3주차

1. 입출력 방식이 프로그램을 이용한 I/O에서 인터럽트를 이용한 I/O로 바뀌는 과정에서 CPU(프로세서)의 역할이 어떻게 달라졌는지 상호 비교하여 기술하시오.
    - 플래그를 계속 감시하지 않고 인터럽스 신호를 인식한다.
2. 동시에 수행되기를 바라는 3가지 작업이 있다고 가정하자. 이를 3개의 프로세스로 구현하는 것과 한 프로세스의 3개 스레드로 구현하는 것의 차이를 설명하시오.
    - 프로세스와 달리 스레드는 코드, 데이터, 힙 영역은 공유하고 각 스레드가 고유한 스택영역을 가진다.
3. 현재 running(실행) 상태에 있는 프로세스가 다음과 같은 경우 어떤 상태로 전이하는 지 선택하시오.  
   파일 입출력 명령을 실행하는데 해당 디스크 블록이 커널 버퍼에 존재함
    - running(실행)
4. 다중프로그래밍 정도(multiprogramming degree)가 너무 높다고 판단되어 조정되는 과정에서 우선순위가 가장 낮아 선택됨
    - suspended(지연)
5. 자식 프로세스가 종료할 때까지 기다려야 하는 상황에서 자식 프로세스가 이미 종료되었음이 확인됨
    - running(실행)
6. 키보드 입력을 기다려야 함
    - blocked(대기)
7. 자신에게 할당된 시간 할당량을 모두 사용함
    - ready(준비)
8. 메모리가 부족하여 할당된 메모리를 임시 반납하고 디스크로 스왚됨
    - suspended(지연)

# 4주차

1. 3 개의 스레드로 구성된 프로세스에서 서로 다른 문맥교환 영역은 최소 몇 개가 필요한가?

    - 2

2. 댜음 설명 중에서 시분할 시스템에 비해 배치 시스템에 더 가까운 설명을 모두 고르시오.

    - 사용자가 결과를 받는 반횐시간이 길다.
    - 문맥 교환이 더 적게 발생한다.
    - 사용자 보다는 시스템 성능 위주로 구현한다.

3. 문맥 교환시 저장되어야 하는 값들을 기술하시오.

    - 실행이 중단될 프로세스의 범용 레지스터의 내용, Program Counter, Stack Pointer 등이 있다.

4. 유닉스에서 새로운 프로세스를 생성하는 시스템 콜은?

    - fork

5. 유닉스의 fork 시스템 콜로 생성되는 자식 프로세스가 부모 프로세스로부터 물려받는(상속) 것을 모두 고르시오.

    - open file 정보
    - 전역변수의 현재 값

6. 다음 중 프로세스 스케줄링이 발생하는 상태 전이는?
    - ready에서 running으로

# 5주차

1. 다음 중 선점 스케줄링을 모두 고르시오.

    - SRTN, RR

2. 현재 running(실행) 상태에 있는 프로세스가 다음과 같은 경우 어떤 상태로 전이하는 지 선택하시오.  
   shortest job first 스케줄링 정책을 사용하는데 자신보다 더 실행시간이 짧은 프로세스가 새로 생성됨

    - running(실행)

3. 현재 running(실행) 상태에 있는 프로세스가 다음과 같은 경우 어떤 상태로 전이하는 지 선택하시오.  
   shortest remaining time first 스케줄링 정책을 사용하는데 자신보다 더 짧은 실행시간을 갖는 프로세스가 새로 생성됨

    - ready(준비)

4. (풀이-2)다음 표는 3개의 프로세스들에 대하여 준비 상태에의 도착시간과 각 프로세스가 필요로 하는 총 실행시간을 보여준다.  
   FIFO 스케줄링을 사용했을 때의 평균대기시간을 구하시오.
    ```
    P1 0 4
    P2 2 6
    P3 6 3
    ```
    - (0+2+4)/3 = 2
5. (풀이-3)SPN(shortest-process-next) 스케줄링을 사용했을 때, 평균응답시간을 구하시오.
    ```
    P1 0 4
    P2 3 5
    P3 6 3
    ```
    - SPN: 실행 시점에 실행시간이 가장 빠른 프로세스부터. 비선점.
    - 평균응답시간 <-> 평균반환시간: Σ(도착시간~서비스 종료시간) / 프로세스 개수
    - ((4-0) + (9-3) + (12-6)) / 3 = 16 / 3
6. SRTN(shortest-remaining-time-next) 스케줄링을 사용했을 때, 프로세스들의 종료 순서를 적으시오.
    ```
    P1 0 6
    P2 2 5
    P3 3 2
    ```
    - SRTN <-> SRT: 실행 시점에 실행시간이 가장 빠른 프로세스부터. 근데 새로 도착한 프로세스의 시간이 더 짧으면 기존의 것을 중단하고 그걸 먼저 실행함.
    - p3 p1 p2
7. HRN(high-response-ratio-next) 스케줄링에서 세 번째로 종료하는 프로세스를 구하시오.
    ```
    P1 0 6
    P2 2 3
    P3 3 5
    ```
    - HRN: 응답률(대기시간 + 서비스시간 / 서비스시간)이 가장 높은 프로세스를 실행함
    - p3

# 6주차

1.  시분할시스템에 비해 일괄처리시스템에 더 가까운 특징을 모두 고르시오.

    -   running 상태에 있는 프로세스가 ready 상태로 바로 전이되는 상황이 발생하지 않는다.
    -   전체 작업을 마치는 시간이 더 짧다
    -   스케줄링 알고리즘 중 라운드로빈 알고리즘이 적당하지 않다.
    -   사용자 환경보다 시스템 환경을 더 고려한다.

2.  (풀이-1) 다음 표는 3개의 프로세스들에 대하여 준비 상태에의 도착시간과 각 프로세스가 필요로 하는 총 실행시간을 보여준다.  
    다단계피드백 스케줄링에서 프로세스들의 종료 순서를 적으시오.  
    새로 도착하는 프로세스는 가강 상위 큐로 삽입하고, 모든 큐의 시간할당량은 3이며, 시간할당량을 소진한 프로세스는 한 단계 낮은 큐로 삽입되도록 한다.

    ```
    P1 0 4 P2 1 5 P3 7 3
    ```

    -   p1 p3 p2

3.  프로세스 동기화를 구현할 때 고려해야 하는 조건과 거리가 먼 것은? - 공유 제거 - 진행, 무기한 연기 방지, 상호 배제는 관련 있음 5. 데커 알고리즘은 \***\*\_\_\_\_\*\***을(를) 구현한 알고리즘이다.
    -   상호배제

# 7주차

1. 데커 알고리즘에 대해 잘못 설명한 것은?

    - 다중프로그래밍 환경에서 사용하지 못한다.

2. 다음 중 busy waiting이 발생하지 않고도 사용 가능한 기법은?

    - 세마포

3. 다음 중 세마포 S에 대한 설명 중 맞는 것은?

    - S의 값이 10과 같이 1보다 큰 값을 갖는 것도 가능하다.

4. 다음 중 이진 세마포에 비해 카운팅 세마포를 사용하는 것이 더 적당한 분야는?

    - 남은 버퍼 개수 제어

5. test-and-set 명령어를 사용하여 아래와 같이 상호배제를 구현하는 프로그램을 작성하였는데 운영체제가 비선점 스케줄링을 사용한다면 어떤 문제점이 발생하는지 설명하시오.

    ```
    while(test-and-set(&lock));
    critical-section-code();
    lock = False;
    ```

    - while부분에서 busy waiting이 발생하고, 비선점 스케줄링이기 때문에 스스로 block되기 전에는 while문을 빠져나올 수 없다.

6. 다음은 원형다중 버퍼 문제의 producer process를 semaphore로 구현한 코드이다.  
   코드 중 V(full); 부분이 생략되면 어떤 문제가 발생하는지 자세히 설명하시오.

    ```
      while(1) {
       .....
       create a new message M;
       P(mutexP);
       P(empty);
       buffer[in] = M;
       in = (in +1) mod N;
       V(full);
       V(mutexP);
       .....
      }
    ```

    V(full)로 소비자 프로세스들에게 채워진 버퍼가 있는 것을 알려야하는데,  
     이것이 없어지면 소비자들은 P(full)에서 계속 block되어있고,  
     결과적으로 버퍼가 비워지지 않으므로 생산자들도 언젠가는 P(empty)에서 더 이상의 빈 버퍼가 없어서 Block되어진다.
