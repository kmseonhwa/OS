# 가상기억장치

-   프로그램을 여러 **블록으로 분할**하고 실행시 필요한 블럭들만  
    **비연속적**으로 주기억장치에 적재시킴
-   연속 적재는 **재배치가 한번만 일어남**
-   _보조기억장치의 일부를 주기억장치처럼 사용하면서  
    현재 필요한 프로그램의 블록 일부만 주기억장치에 로드함(?)_
-   실제 메모리 용량보다 많은 것을 올릴 수 있음

## 비연속 메모리 할당

-   페이징 시스템(paging system)
-   세그먼테이션 시스템(segmentation system)

## 주소 사상 기법 ↔️ 매핑(8)

-   **런타임 바인딩**
-   재배치 없이 매핑할 수 있음
-   블럭 사상(block mapping), 블럭 사상 테이블(block map table)

## 가상메모리

1. **페이징 시스템**(13)

    - 프로그램을 같은 크기의 블럭으로 분할
    - 주기억장치의 페이지 프레임도 페이지와 같은 크기로 분할됨
    - PMT(17)
    - **주소 사상 기법**
        - 직접 사상(direct mapping)(19)
            - PMT가 메모리 위에 존재 -> **주기억장치 접근 회수 2배 증가**
            - 🆚 블럭 매핑: 블럭 번호는 페이지 번호로, 블럭 시작주소는 프레임 넘버로
        - 연관 사상(associative mapping)(30)
            - PMT를 캐시 메모리에 올림
            - 🆚 직접 사상: 인덱스가 아닌 page number 속성을 사용
        - 혼합 사상(mixed direct/associative mapping)(33)
            - 직접 사상 기법과 연관 사상 기법을 같이 사용
            - **지역성**이 높은 페이지를 **연관 기억장치**에 적재함
    - 주기억장치 관리(40)
        - 주기억장치를 페이지 크기와 같은 크기의 페이지 프레임 단위로 미리 분할하여 관리함
    - 페이지 공유(42)
        - 두 페이지가 하나의 페이지 프레임을 공유하려면 두 프로세스의 분기점이 같아야 함

2. **세그먼테이션 시스템**

    - 서로 다른 크기의 블럭으로 분할
    - 주기억장치 영역을 미리 분할 해 둘 수 없음
    - 장점: protection bits가 존재해 각 세그먼트를 논리적으로 접근 허가/불허를 결정하기에 용이함
    - 주소 사상 기법
        - 직접 사상(51)
            - 페이징 시스템보다 매핑 과정 복잡
        - 연관 사상
        - 혼합 사상
    - 접근 제어 기법
        - 읽기(R), 쓰기(W), 실행(X), 붙이기(A)
    - 주기억장치 관리
        - 세그먼트 적재 시에 세그먼트 크기에 맞게 분할
    - 주기억장치 할당을 위한 배치 기법
        - 최초 적합, 최적 적합, 최악 적합, 순환 최초 적합

3. **페이징/세그먼테이션 혼합 기법**(57)

    - 각 프로그램을 세그먼트 단위로 분할하고, 세그먼트를 다시 페이지 단위로 분할함.  
      논리적 관리는 세그먼트 단위, 메모리 할당은 페이지 단위.
    - 장점: 매핑, 메모리 할당이 간편함
    - 단점: 논리적 분할의 개념이 없음, 페이지 공유 문제 등
    - 특징: 세그먼테이션 기법과 달리 존재비트는 없음
    - 주소 사상 기법

        - SMT(61), PMT(62)
        - 직접 사상
            - SMT -> PMT 과정은 복잡, PMT -> main memory는 간결.
        - 연관 사상(66)
            - 주기억장치 액세스를 줄임
            - SMT, PMT를 따로 두지 않고 key를 사용함
        - 혼합 사상(67)
            - 모든 테이블을 캐시에 올릴 수는 없기 때문에 혼합 사상을 사용

    - 주기억장치는 페이지 프레임 단위로 미리 분할되어 있음

# 문제

> 엔트리 개수(26, 표현할 수 있는 최대 페이지의 수), 실주소(26, 페이지 프레임 개수의 비트수만큼 표현), 변위(페이지 크기), 페이지 프레임 개수(28)
> 두 번째 페이지의 시작주소, 몇 번 페이지에 해당하는지(37)
> 주소사상표를 페이징 시스템에서 사용할 때와 세그멘테이션 시스템에서 사용할 때, ... 실주소 찾기(68)
> 내부단편화의 크기, 기법에 따른 페이지 개수 구하기(69)
> 메모리 관리 기법에 따른 바인딩 시간(70)
> 주기억장치 관리시스템에서 발생하는 내부단편화, 외부단편화 현상 차이(71)

---

---

## 추가 학습이 필요한 부분!

-   [ ] 5p, 실제 메모리 용량보다 많은 것을 올릴 수 있다고?  
         결국 실제 주기억장치에 올라가는 건 주기억장치 용량만큼 아닌가?  
         아니면 보조기억장치에 올라가는 것도 메모리에 올렸다고 보는건가?
-   [ ] 15p, 페이징 시스템에서 프로그램 공유나 보호에 있어서 문제가 발생할 수 있다?
-   [ ] 71p
